package cn.jzteam.algorithm.leetcode.question0010;
/*
    给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 '.' 和 '*' 的正则表达式匹配。

    '.' 匹配任意单个字符
    '*' 匹配零个或多个前面的那一个元素
    所谓匹配，是要涵盖 整个 字符串 s的，而不是部分字符串。

    说明:

    s 可能为空，且只包含从 a-z 的小写字母。
    p 可能为空，且只包含从 a-z 的小写字母，以及字符 . 和 *。
    示例 1:

    输入:
    s = "aa"
    p = "a"
    输出: false
    解释: "a" 无法匹配 "aa" 整个字符串。
    示例 2:

    输入:
    s = "aa"
    p = "a*"
    输出: true
    解释: 因为 '*' 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 'a'。因此，字符串 "aa" 可被视为 'a' 重复了一次。
    示例 3:

    输入:
    s = "ab"
    p = ".*"
    输出: true
    解释: ".*" 表示可匹配零个或多个（'*'）任意字符（'.'）。
    示例 4:

    输入:
    s = "aab"
    p = "c*a*b"
    输出: true
    解释: 因为 '*' 表示零个或多个，这里 'c' 为 0 个, 'a' 被重复一次。因此可以匹配字符串 "aab"。
    示例 5:

    输入:
    s = "mississippi"
    p = "mis*is*p*."
    输出: false

    来源：力扣（LeetCode）
    链接：https://leetcode-cn.com/problems/regular-expression-matching
    著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
 */
public class Solution {
    // 动态规划
    // 首先想到当前如果p匹配上s，那么各少一个字符呢，即 f(i) = f(i-1) & s[i] == p[i]
    // 既然想到了字符串的长度变化，就应该扩展到 两个字符串，可能出现 此长彼短、此短彼长 的情况
    // f(i,j) 表示 s的前i个字符和 p的前j个字符 匹配
    // 后来证明，因为 * 一定在字符后方，所以需要倒着匹配。即: f(i, j) 表示s的最后i个字符 和 p的最后j个字符匹配
    // 因为p中有特殊字符，所以需要区分对待：
    // 1、p[j]是普通字符：f(i,j) = p[j] == s[i] && f(i-1, j-1)
    // 2、p[j]是. ：f(i, j) = p[j] == '.' && f(i-1, j-1)
    // 3、p[j]是* ：就要看p[j]的前一个字符是否跟s[i]匹配了
    // 3.1、p[j-1]跟s[i]匹配（相等或者p[j-1]=='.'）: f(i, j) = (p[j-1] == '.' || p[j-1] == s[i]) && f(i-1, j-1)
    // 3.2、p[j-1]跟s[i]不匹配，那p[j]这个*就相当于0，把前一个字符p[j-1]抹掉，相当于p一下子少了两个字符: f(i, j) = (p[j-1] != '.' && p[j-1] != s[i]) && f(i-1, j-2)
    // 现在 i和j 同进退的考虑了，错位的i-j=1也有了，还差j-i=1的情况
    // 只有 p[j]是*，才能实现 f(i,j) = f(i-1, j) && [j]=='*' && j[j-1] != '*'

    // 为什么正确？
    // 先看状态公式是否正确完整，再捋演变过程是否有遗漏
    // 如果没有 * 的存在，那么一定是长度相等，字符匹配：当前匹配依赖上一个是否匹配 f[i+1][j+1]
    // 有了 * 的存在，一定要跟前置字符绑定一起，才能判断（但看*算是不匹配），只有当前字符不是*，后一个是*，才算组合：
    // * 有三种变化：0 1 n
    // 为0，则依靠f[i][j+2]，相当于扣掉 前置字符和* 这两个字符
    // 不为0，那么一定要当前字符是匹配的，再看后面是否匹配。因为后面字符是可以通过*来变化的，所以带着 前置字符和* 跟i+1继续匹配，即 f[i+1][j]，而没用f[i+1][j+1]或者f[i+1][j+2]

    // 再看演变是否有遗漏
    // *可以表示0，把字符变空，所以起点要是空字符，即空串，没有字符。
    // 动态规划的存储跟目标索引一致，从0开始，都表示有字符，只有末尾 s.length和p.length 是越界的没有字符。那么就初始化数组时 +1，用来代表字符串末尾没有字符的位置。
    // 没有字符是起点，所以匹配一定是反向来走了，所以索引都是减减模式。
    // 列举状态出现过的变化：f[i][j]  依赖于  f[i+1][j]    f[i][j+2]    f[i+1][j+1]
    // 摁住一个变量不动，另一个变量是否能正常推演其所有枚举。如果满足，那么推演过程中不会有遗漏。
    // 那么再判断起点时是否越界：j+2在起点时，需要 j+2<p.length（即代码中出现的 j+1<p.length-1）
    // 那么 j=p.length的值可以初始化，一定不匹配，所以j从p.length-1起步，但是这个起点如何初始化呢。
    // 其实当 j+2 越界，就依赖 f[i+1][j+1]了，j+1不会越界。那么i+1会不会越界呢，正好状态公式中有这个逻辑，如果 i+1越界，那么就得到结果了，不依赖f[i+1][j+1]了
    // 所以推演中的起点遗漏也不存在了。
    public static boolean isMatch(String s, String p) {
        boolean[][] f = new boolean[s.length() + 1][p.length() + 1];
        // 初始化边界，长度相同，错位为1的3种情况
        // 注意：边界一定是 ""，因为 a* 能匹配到空，相当于删除 a*。如此就多了一个位置来记录起点。
        // 因为 0表示第一个字符的索引，所以再往前-1表示起点，但是f不方便记录。所以起点从末尾开始，用 s.length 来表示起点，s.length-1是最后一个字符，也是起点。
        f[s.length()][p.length()] = true;

        for (int i=s.length();i>=0;i--) {
            for (int j=p.length()-1;j>=0;j--) {
                char pc = p.charAt(j);
                boolean curMatch = i < s.length() && (s.charAt(i) == pc || pc == '.');

                if (j+1<p.length() && p.charAt(j+1) == '*') {
                    // f[i][j+2] 当前字符无论是否匹配，都能满足
                    // 当前字符匹配 & (f[i+1][j+1] | f[i+1][j])，因为j+1是*，所以不要拆开，直接使用j
                    f[i][j] = f[i][j+2] || (curMatch && f[i+1][j]);
                } else {
                    f[i][j] = curMatch && f[i+1][j+1];
                }
            }
        }
        return f[0][0];
    }

    public static void main(String[] args) {
        System.out.println(isMatch("aa", "a")); // false
        System.out.println(isMatch("aa", "a*")); // true
        System.out.println(isMatch("ab", ".*")); // true
        System.out.println(isMatch("aab", "c*a*b")); // true
        System.out.println(isMatch("mississippi", "mis*is*p*.")); // false
    }
}
